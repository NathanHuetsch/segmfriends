
device: cuda

model:
  model_class: confnets.models.UNet3d
  model_kwargs:
    in_channels: 2
    out_channels: 1
    final_activation: "Sigmoid"
    depth: 3
    upsampling_mode: 'nearest'
    res_blocks_specs: [[True], [True], [True], [True]]
    res_blocks_specs_decoder: [[True], [True], [True], [True]]
    fmaps: [32, 64, 128, 256]
#    return_input: True
    number_multiscale_inputs: 1
    scale_factor: [1, 2, 2]
    norm_type: BatchNorm3d
    loadfrom: '/home/nhuetsch/Desktop/github/segmfriends/experiments/cremi_seeds/runs/exp0/best_checkpoint.pytorch'

loaders:
  infer:
    name: A

inference:
  # How much I crop the predicted tensor: (local_crop in the output resolution)
  crop_prediction:
    - [2,2]
    - [24,24]
    - [24,24]

  # Make sure to exclude the invalid affinities:
  # your model can return a second output tensor that should be a binary tensor indicating with outputs are valid and
  #  which are not
  return_patch_mask: False

  # Change this if the resolution of the output is different from the input:
  output_dws_fact: [1, 1, 1]

  # Should the predicted patches overlap? If yes, by how much?
  window_overlap: [1, 30, 30]
  blending_kwargs:
    dim: 3

  # If your model outputs more than one tensor, use this parameter to select the wanted one
  # TODO: implement multi-output version of the engine
  index_output: 0

